diff --git a/ena/Makefile b/ena/Makefile
index b74e81a..10d4702 100644
--- a/ena/Makefile
+++ b/ena/Makefile
@@ -10,7 +10,7 @@ ena-objs := ena_netdev.o \
 
 ena-$(CONFIG_SYSFS) += ena_sysfs.o
 
-ccflags-y := -I$(src)
+ccflags-y := -I$(src) $(CFLAGS_EXTRA)
 ccflags-y += -I$(src)/$(ENA_COM_PATH)/
 
 
diff --git a/ena/ena_netdev.c b/ena/ena_netdev.c
index 561842a..7d80cff 100644
--- a/ena/ena_netdev.c
+++ b/ena/ena_netdev.c
@@ -56,6 +56,13 @@
 #include "ena_pci_id_tbl.h"
 #include "ena_sysfs.h"
 
+#if IS_ENABLED(CONFIG_NETMAP)
+// glue to include netmap driver specific header file. since the netmap driver was originally
+// implemented for freebsd you need bsd_glue.h to to included in any file that call's netmap
+// specific code.
+#include <ena_netmap_linux.h>
+#endif
+
 static char version[] = DEVICE_NAME " v" DRV_MODULE_GENERATION "\n";
 
 MODULE_AUTHOR("Amazon.com, Inc. or its affiliates");
@@ -94,8 +101,6 @@ MODULE_DEVICE_TABLE(pci, ena_pci_tbl);
 
 static int ena_rss_init_default(struct ena_adapter *adapter);
 static void check_for_admin_com_state(struct ena_adapter *adapter);
-static void ena_destroy_device(struct ena_adapter *adapter, bool graceful);
-static int ena_restore_device(struct ena_adapter *adapter);
 
 #ifdef ENA_XDP_SUPPORT
 static void ena_init_io_rings(struct ena_adapter *adapter,
@@ -117,8 +122,6 @@ static void ena_napi_disable_in_range(struct ena_adapter *adapter,
 				      int first_index, int count);
 static void ena_napi_enable_in_range(struct ena_adapter *adapter,
 				     int first_index, int count);
-static int ena_up(struct ena_adapter *adapter);
-static void ena_down(struct ena_adapter *adapter);
 static void ena_unmask_interrupt(struct ena_ring *tx_ring,
 				 struct ena_ring *rx_ring);
 static void ena_update_ring_numa_node(struct ena_ring *tx_ring,
@@ -1316,6 +1319,18 @@ static int ena_clean_tx_irq(struct ena_ring *tx_ring, u32 budget)
 	int tx_pkts = 0;
 	int rc;
 
+#if IS_ENABLED(CONFIG_NETMAP)
+	// netmap mode all work is done in client thread nothing is done below.
+	// napi only wakes up these threads who might be waiting on queues.
+	struct ena_adapter *adapter = tx_ring->adapter;
+	if (netmap_tx_irq(adapter->netdev, tx_ring->qid) != NM_IRQ_PASS) {
+		// should I return 0. this mean's I have consumed all my budget
+		// and napi won't reschedule me immediately or should I return budget based
+		// on resched check.
+		return 0;
+	}
+#endif
+
 	next_to_clean = tx_ring->next_to_clean;
 	txq = netdev_get_tx_queue(tx_ring->netdev, tx_ring->qid);
 
@@ -1692,6 +1707,9 @@ static int ena_clean_rx_irq(struct ena_ring *rx_ring, struct napi_struct *napi,
 #endif /* ENA_XDP_SUPPORT */
 	int rc = 0;
 	int i;
+#if IS_ENABLED(CONFIG_NETMAP)
+	int dummy, nm_irq;
+#endif
 
 	netif_dbg(rx_ring->adapter, rx_status, rx_ring->netdev,
 		  "%s qid %d\n", __func__, rx_ring->qid);
@@ -1700,6 +1718,13 @@ static int ena_clean_rx_irq(struct ena_ring *rx_ring, struct napi_struct *napi,
 	xdp.rxq = &rx_ring->xdp_rxq;
 #endif /* ENA_XDP_SUPPORT */
 
+#if IS_ENABLED(CONFIG_NETMAP)
+	nm_irq = netmap_rx_irq(rx_ring->netdev, rx_ring->qid, &dummy);
+	if (nm_irq != NM_IRQ_PASS)
+		return 0; // need to check if I need to check resched.
+		// return (nm_irq == NM_IRQ_RESCHED) ? budget : 1;
+#endif
+
 	do {
 #ifdef ENA_XDP_SUPPORT
 		xdp_verdict = XDP_PASS;
@@ -2754,7 +2779,7 @@ err_setup_tx:
 	}
 }
 
-static int ena_up(struct ena_adapter *adapter)
+int ena_up(struct ena_adapter *adapter)
 {
 	int io_queue_count, rc, i;
 
@@ -2825,7 +2850,7 @@ err_req_irq:
 	return rc;
 }
 
-static void ena_down(struct ena_adapter *adapter)
+void ena_down(struct ena_adapter *adapter)
 {
 	int io_queue_count = adapter->num_io_queues + adapter->xdp_num_queues;
 
@@ -3874,7 +3899,7 @@ err_disable_msix:
 	return rc;
 }
 
-static void ena_destroy_device(struct ena_adapter *adapter, bool graceful)
+void ena_destroy_device(struct ena_adapter *adapter, bool graceful)
 {
 	struct net_device *netdev = adapter->netdev;
 	struct ena_com_dev *ena_dev = adapter->ena_dev;
@@ -3921,7 +3946,7 @@ static void ena_destroy_device(struct ena_adapter *adapter, bool graceful)
 	clear_bit(ENA_FLAG_DEVICE_RUNNING, &adapter->flags);
 }
 
-static int ena_restore_device(struct ena_adapter *adapter)
+int ena_restore_device(struct ena_adapter *adapter)
 {
 	struct ena_com_dev_get_features_ctx get_feat_ctx;
 	struct ena_com_dev *ena_dev = adapter->ena_dev;
diff --git a/ena/ena_netdev.h b/ena/ena_netdev.h
index 025774a..e4f2f30 100644
--- a/ena/ena_netdev.h
+++ b/ena/ena_netdev.h
@@ -51,6 +51,10 @@
 #include "ena_com.h"
 #include "ena_eth_com.h"
 
+#if IS_ENABLED(CONFIG_NETMAP)
+#include <bsd_glue.h>
+#endif
+
 #define DRV_MODULE_GEN_MAJOR	2
 #define DRV_MODULE_GEN_MINOR	2
 #define DRV_MODULE_GEN_SUBMINOR 7
@@ -199,6 +203,14 @@ struct ena_calc_queue_size_ctx {
 	u16 max_rx_sgl_size;
 };
 
+#if IS_ENABLED(CONFIG_NETMAP)
+struct ena_netmap_tx_info {
+	uint32_t socket_buf_idx[ENA_PKT_MAX_BUFS];
+	bus_dmamap_t map_seg[ENA_PKT_MAX_BUFS]; /* bus_dmamap_t = dma_addr_t bsd_glue.h takes care of it. */
+	unsigned int sockets_used;
+};
+#endif
+
 struct ena_tx_buffer {
 	struct sk_buff *skb;
 	/* num of ena desc for this specific skb
@@ -226,6 +238,11 @@ struct ena_tx_buffer {
 
 	/* Used for detect missing tx packets to limit the number of prints */
 	u32 print_once;
+
+#if IS_ENABLED(CONFIG_NETMAP)
+	struct ena_netmap_tx_info nm_info;
+#endif /* CONFIG_NETMAP */
+
 	/* Save the last jiffies to detect missing tx packets
 	 *
 	 * sets to non zero value on ena_start_xmit and set to zero on
@@ -244,6 +261,9 @@ struct ena_rx_buffer {
 	struct page *page;
 	u32 page_offset;
 	struct ena_com_buf ena_buf;
+#if IS_ENABLED(CONFIG_NETMAP)
+	uint32_t netmap_buf_idx;
+#endif /* CONFIG_NETMAP */
 } ____cacheline_aligned;
 
 struct ena_stats_tx {
@@ -347,6 +367,11 @@ struct ena_ring {
 #if ENA_BUSY_POLL_SUPPORT
 	atomic_t bp_state;
 #endif
+#if IS_ENABLED(CONFIG_NETMAP)
+	/* How many packets are sent in one Tx loop, used for doorbells */
+	uint32_t acum_pkts;
+	bool initialized;
+#endif
 } ____cacheline_aligned;
 
 #if ENA_BUSY_POLL_SUPPORT
@@ -614,4 +639,11 @@ static inline enum ena_xdp_errors_t ena_xdp_allowed(struct ena_adapter *adapter)
 }
 #endif /* ENA_XDP_SUPPORT */
 
+// used by ena_netmap.c. netmap driver support needs to do certain operation's hence
+// we need these function's avaliable across driver.
+int ena_up(struct ena_adapter *adapter);
+void ena_down(struct ena_adapter *adapter);
+void ena_destroy_device(struct ena_adapter *adapter, bool graceful);
+int ena_restore_device(struct ena_adapter *adapter);
+
 #endif /* !(ENA_H) */
diff --git a/ena/ena_netmap_linux.h b/ena/ena_netmap_linux.h
new file mode 100644
index 0000000..9d971a2
--- /dev/null
+++ b/ena/ena_netmap_linux.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2020 Amit Shinde. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * netmap support for: ena (linux version)
+ */
+
+#include <bsd_glue.h>
+#include <net/netmap.h>
+#include <netmap/netmap_kern.h>
+#include <ena_netdev.h>
+
+#ifndef ENA_NETMAP_LINUX_H
+#define ENA_NETMAP_LINUX_H
+
+/*
+ * attach routine called from ena driver. This is the main routine which
+ * set's up your netmap_attach() parameters.
+ */
+int ena_netmap_attach(struct ena_adapter *);
+
+int ena_netmap_alloc_rx_slot(struct ena_adapter *, struct ena_ring *, struct ena_rx_buffer *);
+void ena_netmap_free_rx_slot(struct ena_adapter *, struct ena_ring *, struct ena_rx_buffer *);
+bool ena_rx_ring_in_netmap(struct ena_adapter *, int);
+bool ena_tx_ring_in_netmap(struct ena_adapter *, int);
+void ena_netmap_reset_rx_ring(struct ena_adapter *, int);
+void ena_netmap_reset_tx_ring(struct ena_adapter *, int);
+void ena_netmap_unload(struct ena_adapter *, bus_dmamap_t);
+
+#endif
